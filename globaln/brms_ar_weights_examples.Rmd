---
title: "Quick brms example"
author: "Quentin D. Read"
date: "12/18/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This is an example of a brms model with temporal autocorrelation and weights. The fake data don't really illustrate the effect of properly accounting for temporal autocorrelation, or for weighting. This is more to just confirm everything works as expected.

## load packages

```{r, message = FALSE}
library(brms)
library(tidybayes)
library(tidyverse)
```

## generate fake data

```{r}
set.seed(410)
year <- 1:50
# x is random walk
x <- cumsum(rnorm(n = 50, mean = 1, sd = 3))
y <- 2 * x + 10 + rnorm(n = 50, mean = 0, sd = 5) + cumsum(rnorm(n = 50, mean = 0.25, sd = 1))

# Weights set to increase linearly over time (stupid)
weights <- 1:50

fakedata <-  data.frame(year = year,x = x, y = y, w = weights)
```

The `x` variable is a random walk with an increasing trend, and the `y` variable is a linear function of `x` with some random noise added plus another independent random walk component.

Plot the fake data.

```{r}
p <- ggplot(fakedata) + theme_minimal()

p + geom_line(aes(x = year, y = x))
p + geom_line(aes(x = year, y = y))
p + geom_line(aes(x = x, y = y))
```

## fit some models

I fit a basic linear model to the relationship, with no weights or autocorrelation accounted for. In the second fit, I added AR1 autocorrelation (random walk where each point only depends on the one just before it), and in the third fit I also added weights where more recent observations are weighted more highly. I kept all default priors and assumed Gaussian error distributions (just nice and simple).

```{r}
# Fit with no weights, no autocorrelation
# No priors. Assume Gaussian distribution (all defaults)
fit_noweight_noautocorr <- brm(y ~ x, data = fakedata, chains = 2, iter = 1000)

# Fit with no weights, yes autocorrelation (AR1)
fit_noweight_ar1 <- brm(y ~ x + ar(time = year, p = 1), data = fakedata, chains = 2, iter = 1000)

# Fit with yes weights, yes autocorrelations
fit_weight_ar1 <- brm(y | weights(w) ~ x + ar(time = year, p = 1), data = fakedata, chains = 2, iter = 1000)
```

## look at the summaries

There are a lot of fit diagnostics you can plot with the `bayesplot` package but I will not show them here. Just the fixed effect coefficient estimates which should be 10 for intercept and 2 for slope.

```{r}
summary(fit_noweight_noautocorr)
summary(fit_noweight_ar1)
summary(fit_weight_ar1)
```

## plot the fixed effects

This is done with the help of the `tidybayes` package.

```{r}
model_fixefs <- list(linear_fit = fit_noweight_noautocorr, noweight_ar1 = fit_noweight_ar1, weighted_ar1 = fit_weight_ar1) %>%
  map_dfr(~ spread_draws(., b_Intercept, b_x), .id = 'model') %>%
  pivot_longer(c(b_Intercept, b_x), names_to = 'parameter') %>%
  group_by(model, parameter) %>%
  summarize(q025 = quantile(value, 0.025), q50 = quantile(value, 0.5), q975 = quantile(value, 0.975))

ggplot(model_fixefs, aes(x = model, ymin = q025, y = q50, ymax = q975)) +
  facet_wrap(~ parameter, labeller = labeller(parameter = c(b_Intercept = 'intercept', b_x = 'slope')), nrow = 2, scales = 'free_y') +
  geom_pointrange() +
  theme_minimal()
  
```

